<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>For the north</title>
  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
  <link rel="stylesheet" href="/for-the-north-static/public/prism.css">
  <link rel="stylesheet" href="/for-the-north-static/public/styles.css">
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
</head>
<body>
  <nav class="navbar">
    <a class="logo" href="/for-the-north-static/pages/index.html">
        <strong>FTN</strong>
    </a>
  </nav>
  <aside class="sidebar">
    <a class="nav-link" href="/for-the-north-static/pages/posts.html">Posts</a>
    <a class="nav-link" href="/for-the-north-static/pages/about.html">About</a>
  </aside>
  <main class="main post-body">
    <h2 class="post-headline">
      Prototypes, feared by many, dominated by a few.
    </h2>
    <p>
      Even with all the hype that many of us OOP programmers out there trying
      to get our ways, and implement our beloved patterns, it seems difficult
      even to use the most simple features of JavaScript along this paradigm.
    </p>
    <p>
      Don't worry, I understand.
    </p>
    <p>
      But when dark times come, these usually bring people that have experienced
      some sort of this cloudy and shadow neighborhoods that make us tremble when
      the project manager says:
    </p>
    <p class="dialog">
        "Hey, we are getting some issues in the product page,
        would you mind taking a look?"
    </p>
    <p class="sneaky-action">
        * project manager flees and leaves you to die*
    </p>
    <p>
      So, let's get started for once.
    </p>
    <p>
      Prototypes pretty much work the same way as object instances in <span id="code-tag-1" class="code">Java/C#/PHP</span> do.
    </p>
    <p>
      You add a few "attributes" and "methods" to have some features and functionality or behavior going, and you're good to go.
    </p>
    <p>
      Things get fuzzy when we attempt to mess with the word <span id="code-tag-2" class="code">this</span>.
    </p>
    <p>
      First, to wrap our heads around this, we must run into some
      samples so we can put our terms over the table and actually
      see what's going on. Suppose we have the following code samples:
    </p>
    <h3>ES5</h3>
    <div class="code-section">
        <input type="checkbox" class="collapse-checkbox" id="collapse-1">
        <label class="collapse-toggle" for="collapse-1" title="Click to toggle expand/collapse">
        </label>
        <pre class="collapse-content">
        <code class="code language-javascript">
          function Person(personName){
            this.personName = personName
            this.sayHi = function() {
              console.log("Hi! I'm " + this.personName)
            }
          }
  
          var johnSmith = new Person('John Smith')
          johnSmith.sayHi()
        </code>
      </pre>
    </div>
    <h3>ES6</h3>
    <div class="code-section">
        <input type="checkbox" class="collapse-checkbox" id="collapse-2">
        <label class="collapse-toggle" for="collapse-2" title="Click to toggle expand/collapse">
        </label>
        <pre class="collapse-content">
        <code class="code language-javascript">
          class Person {
            constructor(personName) {
              this.personName = personName
            }

            sayHi() {
              console.log(`Hi! I'm ${this.personName}`)
            }
          }

          const johnSmith = new Person('John Smith')
          johnSmith.sayHi()
        </code>
      </pre>
    </div>

    <p>
      A pretty normal code if you ask me.
      Nothing wrong with it. You can get out even
      by just calling <code>johnSmith.sayHi()</code>
      and you're good to go. Both samples are just fine.
    </p>
    <p>
      Now, let's get further.
      What would happen if we wanted to create a special
      prototype to handle a few click events from a page?
      Let's take a look:
    </p>
    <p>
      <div class="code-section">
            <input type="checkbox" class="collapse-checkbox" id="collapse-3">
            <label class="collapse-toggle" for="collapse-3" title="Click to toggle expand/collapse">
            </label>
            <pre class="collapse-content">
            <code class="code language-javascript">
              // JavaScript: index.js
              class ClickListener {
                constructor(button) {
                  this.button = button
                  this.counter = 0
                  this.button.addEventListener('click', this.handleClick)
                }

                handleClick() {
                  this.counter++
                  const counterHolder = document.querySelector('#counter')
                  counterHolder.innerHTML = `You clicked ${this.counter} times`
                }
              }

              const button = document.querySelector('#count-button')
              const listener = new ClickListener(button)
            </code>

            <code class="code language-html">
              &lt;!--HTML: index.html --&gt;
                  &lt;html&gt;
                    &lt;head&gt;&lt;/head&gt;
                    &lt;body&gt;
                      &lt;div&gt;
                        &lt;input type="button" id="count-button"&gt;
                        &lt;div id="counter" &gt;
                          You clicked 0 times
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;script src="./index.js"&gt;&lt;/script&gt;
                    &lt;/body&gt;
                  &lt;/html&gt;

              </code>
          </pre>
      </div>
    </p>
    <p>
      I want you to try this code.
      Visit a site like <a href="https://codesandbox.io">Code Sandbox</a>
      or <a href="https://codepen.io">CodePen</a>.
      The result of that code will be the same. Both sites will
      show, according to that script, that you clicked the button
      by "NaN" times.
    </p>

    <p>
      Why is this behavior going? Are we doing things wrong?
      Do we need to relearn the OOP concepts again? None of the
      2 latest questions.
    </p>
    <p>
      What we are facing here is the behavior of JavaScript itself.
      It's something we might not be aware of. It's something that,
      for the purposes stated here, we'll refer to as the "Context".
      Context is not like the scope. Context is something that comes
      to life once we are executing code. 
    </p>
    <p>
      The Context is the underlying reference from where the current
      bound function will work with. 
      In a simpler way, it is the reference to which the word <code>this</code>
      will point to, during execution.
    </p>
    <p>
      In other words, this means that you will truly and absolutely know
      what <code>this</code> is only during runtime (of course, this is if
      you are good as debugger).
    </p>
    <p>
      <strong>BUT!</strong>
      There's a way for you to know what the <code>this</code> context will
      be. Although, I must say, this is error prone, with the right attitude,
      and a good knowledge of the right tools, you'll be safe from cutting
      yourself (too much) in the process. The cornerstones for <code>this</code>
      are composed of two parts: the rules and exceptions of the <code>this</code>
      context.
    </p>
    <a id="rules" href="/for-the-north-static/pages/posts/prototypes.html#rules">
    <h3>
      Rules
    </h3>
    </a>
    <p>
      There are 4 rules that reign over the <code>this</code>
      kingdom, each with its own name:
      <ul class="list">
        <li>
          <h4>Default binding</h4>
          <p>
            This context binding is the one that fallbacks to the <code>global</code>
            object, or, in other words, mostly everything that lies in the global
            scope.
          </p>
          <p>
            Let's say we have the following code:
            <div class="code-section">
                <input type="checkbox" class="collapse-checkbox" id="collapse-4">
                <label class="collapse-toggle" for="collapse-4" title="Click to toggle expand/collapse">
                </label>
                <pre class="collapse-content">
                <code class="code language-javascript">
                  var personName = "Steve"
                  function printMyName() {
                    console.log(this.personName)
                  }

                  printMyName()
                </code>
              </pre>
            </div>

            Try this out. This will result with the string "Steve" in the console.
            The engine will look up for the closest context object to have the property
            <code>name</code>.

            <p>
              This rule also applies by depth:
              <div class="code-section">
                  <input type="checkbox" class="collapse-checkbox" id="collapse-5">
                  <label class="collapse-toggle" for="collapse-5" title="Click to toggle expand/collapse">
                  </label>
                  <pre class="collapse-content">
                  <code class="code language-javascript">
                    var personName = "Steve"
                    function printName() {
                      function printGlobalName() {
                        console.log(this.personName)
                      }
                      printGlobalName()
                    }
  
                    printName()
                  </code>
                </pre>
              </div>
            </p>
          </p>
        </li>
        <li>
          <h4>Implicit binding</h4>
          <p>
            This context binding is applied depending from where a particular function
            was called, including if this was called by an eligible context object. 
            You can call this the <code>call-site</code>. 
          </p>
          <p>Given the following code:</p>
          <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-6">
              <label class="collapse-toggle" for="collapse-6" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                const GUEST = 0
                const CLIENT = 1
                const MASTER = 2
                function open(door) {
                  let opened = false
                  if(this.cardKey){
                    switch(door.id) {
                      case GUEST:
                        opened = this.cardKey === 'guest'
                          break
                        case CLIENT:
                          opened = this.cardKey === 'AKJboq38h48fhIB'
                          break
                        case MASTER:
                          opened = this.cardKey === 'master'
                          break
                      }
                    }
                    console.log(`Access ${opened ? 'Authorized' : 'denied'}`)
                    return opened
                  }
                  let cardKey = 'guest'
                  let clientCardKey = 'AKJboq38h48fhIB'

                  let guest = {
                    name: 'Tom',
                    position: 'Guest',
                    open,
                  }

                  let client = {
                    name: 'Jerry',
                    cardKey: clientCardKey,
                    position: 'Client',
                    open,
                  }

                  let janitor = {
                    name: 'Hank',
                    position: 'Janitor',
                    cardKey: 'master',
                    open,
                  }

                  let doors = 
                    {
                      guest: {
                        id: 0,
                        requiredCardKey: 'guest'
                      },
                      client:{
                        id: 1,
                        requiredCardKey: 'AKJboq38h48fhIB'
                      },
                      master:{
                        id: 2,
                        requiredCardKey: 'master'
                      }
                    }

                  client.open(doors.client)
                  janitor.open(doors.master)
                  guest.open(doors.guest) // Suspicious...
              </code>
            </pre>
          </div>
        </li>
        <li>
          <h4>
            Explicit Binding
          </h4>
          <p>
            This type of binding is the one that lets you, through a range of selected functions, apply a context object
            explicitly, allowing you to work the way you intend. Let's take the following example:
            <div class="code-section">
                <input type="checkbox" class="collapse-checkbox" id="collapse-7">
                <label class="collapse-toggle" for="collapse-7" title="Click to toggle expand/collapse">
                </label>
                <pre class="collapse-content">
                <code class="code language-javascript">
                  class Employee {
                    constructor(employeeName, employeeCode) {
                      this.employeeName = employeeName
                      this.employeeCode = employeeCode
                    }

                    getEmployeeCode(){
                      return this.employeeCode
                    }
                  }


                  class Printer {
                    print() {
                      console.log(`${this.employeeName}'s Code: ${this.employeeCode}`)
                    }
                  }

                  const printer = new Printer()
                  const john = new Employee('John', '129dgKi3')
                  const jack = new Employee('Jack', '1p209udc')

                  // Using 'apply'
                  printer.print.apply(john)
                  printer.print.apply(jack)

                  // And the same can be achieved with 'call'
                  printer.print.call(john)
                  printer.print.call(jack)
                </code>
              </pre>
            </div>
            <code>call</code> and <code>apply</code> let you define a context object of your choice and use it
            as the <code>this</code> of the function you are using. The difference between these functions is that,
            <code>call</code> will receive, as its first argument, the context object, followed by each of the original
            function's arguments, resembling its signature, while <code>apply</code> will receive, the context object as
            its first argument, and the second argument will be an array, resembling each of the original function's arguments,
            respectively, so, be careful on the second one.
          </p>
        </li>
        <li>
          <h4>
            <code>new</code> Binding (Prototype creation)
          </h4>
            <p>
              This type of context binding is one of the most familiar for the OOP programmer, and perhaps,
              the most dangerous of them all. Don't let it fool you, it only pleases the eyes, and becomes
              like a candy for the developer. The more you do it without care, the more you harm yourself.
              From experience, I can tell you, it's not like OOP.

              This particular binding, instead of adopting and mimicking our beloved OOP concepts
              and behaviors, follows the "context is bound at execution" nature, and should be used
              with deliberate care. This is like taking the training wheels off your bike.

              Now, if you got this far, and feel ready for it (because we don't ever know when we are until we use 
              or do something new - haha, pun intended), let's check the following code:
              <div class="code-section">
                <input type="checkbox" class="collapse-checkbox" id="collapse-8">
                <label class="collapse-toggle" for="collapse-8" title="Click to toggle expand/collapse">
                </label>
                <pre class="collapse-content">
                <code class="code language-javascript">
                  function Car() {
                    this.carName = 'Mustang'
                    this.carColor = 'Metalic Silver/Black'
                  }

                  Car()

                  // Will this work? 
                  console.log(carName)
                </code>
              </pre>
            </div>
            Here we are, declaring a function that sets the properties <code>name</code>
            and <code>color</code> to the context object, but we haven't referred to any...
            So... which context object are we working with then? In the sample above, we
            refer to <code>name</code> in the <code>console.log()</code> call as a global
            variable, then we must be able to see it from there. You may say: "That's ... not very
            helpful though, if you ask me...". Yes, maybe we'll be able to tweak this sample a bit
            to make it a little more reusable:
            <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-9">
              <label class="collapse-toggle" for="collapse-9" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                function Car(carName, carColor) {
                  this.carName = carName
                  this.carColor = carColor
                }

                Car('Ferrari', 'Red')

                
                console.log(carName)
                console.log(carColor)
              </code>
            </pre>
          </div>
            Now we're talking. We have a function that can change some property values!
            But hey... this isn't very helpful, you may say, and you also may point out
            that we could've just declared two global variables and use them instead, so,
            what gives? Well, this is where our <code>new</code> operator comes in.

            Take a look at this:
            <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-10">
              <label class="collapse-toggle" for="collapse-10" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                function Car(carName, carColor) {
                  this.carName = carName
                  this.carColor = carColor
                }

                const ferrari = new Car('Ferrari', 'Red')

                console.log(carName) // ReferenceError
                console.log(carColor) // ReferenceError
              </code>
            </pre>
          </div>
          Whoa! Witchcraft here! Actually, no. Our <code>new</code> operator did
          all the trick. What this lil' buddy here does is that, out of nothing (like magic, but no),
          creates a new context object from where to work with, and if assigned, allocates its reference,
          giving you the power to work from there, so, everything related to the values you assigned to that
          context object, will be available and accesible from there. You can say that it brings some sort of isolation,
          but you can still do some tricks to fool your "object", since there are no access modifiers as there are in other
          programming languages. This type of context binding is related with prototypes, and serves the purpose
          of the post here. Now you might wonder... why use them? Well, besides using them as structures for many tasks
          or problems you might have, let's use an example to ilustrate why they may be useful. 
          </p>
          <p>
          Let's say that you work as a software developer in a franchise of reknowned cinema, and you are the one in charge
          of receiving ticket orders. After a user at a web page attempts to pay the ticket, a request is sent and you need to
          create and verify the information for the payment. Your job is to create a final JSON-format structure that resembles
          the purchase of a ticket, and send it to a server, where the payment will be processed. So, your tasks would be:
          <ol>
            <li>Create a validator for the data</li>
            <li>Create a JSON Format Plotter</li>
            <li>Create a data forward mechanism</li>
          </ol>

          So, you might as well do it with functions, but that would imply that I have availability of functions
          meandering around there with very specific tasks, which would not be reusable for any other things, so,
          you might as well isolate these behaviors in definite structures, just like you would do in OOP, but, now
          that you know the very basics, you can do it here in JavaScript too!
          So, to begin with the task at hand, first we need to know the information we are going to receive.
          For the sake of this example, let's assume we receive the following:
          <div class="code-section">
            <input type="checkbox" class="collapse-checkbox" id="collapse-11">
            <label class="collapse-toggle" for="collapse-11" title="Click to toggle expand/collapse">
            </label>
            <pre class="collapse-content">
            <code class="code language-javascript">
              {
                "customerName" : "Jack Hollins",
                "cardNumber" : "XXXX-XXXX-XXXX-XXXX", // Stop wondering why would someone do this. It's not right.
                "cardCompany" : "VISA", // In any case, you would use some encrypted info anyways.
                "cardCode" : "", // Ok, you win, we can refer to encryption in another post.
                "cardExpiration": "10/99" // And JWT too, why not? 
              }
            </code>
          </pre>
        </div>
        Of course, we receive this info, but not on this format. We receive it directly from
        the fields on the site. To generate the format above, first we need to validate it.
        So, before we begin with prototype creation, remember: Prototypes are prototypes, no matter
        what, whether you use the in the ES6 <code>class</code> form or the regular function form.
        For the sake of this example, we'll use the ES6 form:
        <div class="code-section">
          <input type="checkbox" class="collapse-checkbox" id="collapse-12">
          <label class="collapse-toggle" for="collapse-12" title="Click to toggle expand/collapse">
          </label>
          <pre class="collapse-content">
          <code class="code language-javascript">
            class PaymentInfoValidator {
              constructor(customerName, cardNumber, cardCompany, cardCode, cardExpiration) {
                this.customerName = customerName
                this.cardNumber = cardNumber
                this.cardCompany = cardCompany
                this.cardCode = cardCode
                this.cardExpiration = cardExpiration
              }

              // To validate entire info
              isValidInfo() {
                return (
                  this.isValidCardNumber() &&
                  this.isValidCardCompany() &&
                  this.isValidCardCode() &&
                  this.isValidCardExpiration()
                )
              }

              isValidCardNumber() {
                return /(([0-9]{4})\-){3}[0-9]{4}/.test(this.cardNumber)
              }

              isValidCardCompany() {
                return (
                  this.cardCompany === 'VISA' ||
                  this.cardCompany === 'MASTERCARD'
                )
              }

              isValidCardCode() {
                return /[0-9]{3}/.test(this.cardCode)
              }

              isValidCardExpiration() {
                return /(([0][1-9])|([1][0-2]))[/]([1-9]{2})/.test(this.cardExpiration)
              }
            }
          </code>
        </pre>
      </div>
      As the means for the validation, we'll just check the format. <code>isValidInfo</code>
      will use the remaining validation functions to check each of the fields sent to our
      prototype. <code>isValidCardNumber</code> will check the format of the card number, via
      our first regular expression. For it to be valid, it needs to have 4 sequences of 4 digits,
      separated by a hyphen (-). For the card company, we've included 2 possible companies: Visa and
      Mastercard. After that, we just validate that the card code has 3 digits. And finally, we check
      card expiration from the date this post was written and onwards until 2099. So, we've got how to
      validate our information. Now we can pass directly to our plotter:
      <div class="code-section">
        <input type="checkbox" class="collapse-checkbox" id="collapse-13">
        <label class="collapse-toggle" for="collapse-13" title="Click to toggle expand/collapse">
        </label>
        <pre class="collapse-content">
        <code class="code language-javascript">
          class PaymentInfoJSONPlotter {
            constructor(customerName, cardNumber, cardCompany, cardCode, cardExpiration) {
              this.customerName = customerName
              this.cardNumber = cardNumber
              this.cardCompany = cardCompany
              this.cardCode = cardCode
              this.cardExpiration = cardExpiration
            }

            getJSON() {
              return {
                customerName : this.customerName,
                cardNumber : this.cardNumber,
                cardCompany : this.cardCompany,
                cardExpiration: this.cardExpiration,
              }
            }
          }
        </code>
      </pre>
    </div>
    Now we got our plotter, although, this sample seems pretty straightforward and orthodox from
    OOP patterns, there's a minor detail I'd like to remark here. Even though we use <code>new</code>
    as our object construction of a prototype, there's a simpler way to do this. If we know that objects
    can be taken as context objects, we can use a trick to bind a context to our new object from our
    <code>PaymentInfoValidator</code> object. Constructor calls in JavaScript are not distinct from
    a normal function call, and do not operate the same way as in OOP languages. Constructor calls
    are just functions with the <code>new</code> operator in front of them, and, create a new object
    from where to work with as the context of the new prototype object. This can be changed, as, in
    constructor calls, it is allowed to return an object as the context, therefore, allowing to work
    from there. So we can rewrite our sample. Imagine we get and validate our info as the following
    from the DOM:
    <div class="code-section">
        <input type="checkbox" class="collapse-checkbox" id="collapse-14">
        <label class="collapse-toggle" for="collapse-14" title="Click to toggle expand/collapse">
        </label>
        <pre class="collapse-content">
        <code class="code language-javascript">
            var customerName = 'Jack Hollins'
            var cardNumber = '1111-1111-1111-1111'
            var cardCompany = 'VISA'
            var cardCode = '123'
            var cardExpiration = '10/99'
  
            let info = {
              customerName,
              cardNumber,
              cardCompany,
              cardCode,
              cardExpiration,
            }
  
            class PaymentInfoValidator {
              constructor() {
                return {
                  ...info,
                  isValidInfo: this.isValidInfo,
                  isValidCardNumber: this.isValidCardNumber,
                  isValidCardCompany: this.isValidCardCompany,
                  isValidCardCode: this.isValidCardCode,
                  isValidCardExpiration: this.isValidCardExpiration,
                }
              }
  
              // To validate entire info
              isValidInfo() {
                return (
                  this.isValidCardNumber() &&
                  this.isValidCardCompany() &&
                  this.isValidCardCode() &&
                  this.isValidCardExpiration()
                )
              }
  
              isValidCardNumber() {
                return /(([0-9]{4})\-){3}[0-9]{4}/.test(this.cardNumber)
              }
  
              isValidCardCompany() {
                return (
                  this.cardCompany === 'VISA' ||
                  this.cardCompany === 'MASTERCARD'
                )
              }
  
              isValidCardCode() {
                return /[0-9]{3}/.test(this.cardCode)
              }
  
              isValidCardExpiration() {
                return /(([0][1-9])|([1][0-2]))[/]([1-9]{2})/.test(this.cardExpiration)
              }
            }
        </code>
      </pre>
    </div>
        Well, we now don't need to pass all info to our constructor call. However, 
        it can be even simpler. How far can we go? As far as not needing prototypes:
        <div class="code-section">
            <input type="checkbox" class="collapse-checkbox" id="collapse-15">
            <label class="collapse-toggle" for="collapse-15" title="Click to toggle expand/collapse">
            </label>
            <pre class="collapse-content">
            <code class="code language-javascript">
                var customerName = 'Jack Hollins'
                var cardNumber = '1111-1111-1111-1111'
                var cardCompany = 'VISA'
                var cardCode = '123'
                var cardExpiration = '10/99'
      
                let info = {
                  isValidCardNumber: () => /(([0-9]{4})\-){3}[0-9]{4}/.test(this.cardNumber),
                  isValidCardCompany: () => this.cardCompany === 'VISA' || this.cardCompany === 'MASTERCARD',
                  isValidCardCode: () => /[0-9]{3}/.test(this.cardCode),
                  isValidCardExpiration: () => /(([0][1-9])|([1][0-2]))[/]([1-9]{2})/.test(this.cardExpiration),
                }
            </code>
          </pre>
        </div>
          Although simpler and we lost our <code>isValidInfo</code> function, we have those variables as globals, hence, not quite practical, so,
          let's go back to our prototype approach, but, in more practical terms:
          <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-16">
              <label class="collapse-toggle" for="collapse-16" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                // Mocking the values:
                  let paymentInfo = {
                    customerName : 'Jack Hollins',
                    cardNumber : '1111-1111-1111-1111',
                    cardCompany : 'VISA',
                    cardCode : '123',
                    cardExpiration : '10/99',
                  }
        
                  class PaymentInfoValidator {
                    constructor(paymentInfo) {
                      // As we are writing in the ES6 standard, we take advantage of it,
                      // using destructuring assignment :
                      const { 
                        customerName,
                        cardNumber,
                        cardCompany,
                        cardCode,
                        cardExpiration 
                      } = paymentInfo
                      this.customerName = customerName
                      this.cardNumber = cardNumber
                      this.cardCompany = cardCompany
                      this.cardCode = cardCode
                      this.cardExpiration = cardExpiration
                    }
        
                    // To validate entire info
                    isValidInfo() {
                      return (
                        this.isValidCardNumber() &&
                        this.isValidCardCompany() &&
                        this.isValidCardCode() &&
                        this.isValidCardExpiration()
                      )
                    }
        
                    isValidCardNumber() {
                      return /(([0-9]{4})\-){3}[0-9]{4}/.test(this.cardNumber)
                    }
        
                    isValidCardCompany() {
                      return (
                        this.cardCompany === 'VISA' ||
                        this.cardCompany === 'MASTERCARD'
                      )
                    }
        
                    isValidCardCode() {
                      return /[0-9]{3}/.test(this.cardCode)
                    }
        
                    isValidCardExpiration() {
                      return /(([0][1-9])|([1][0-2]))[/]([1-9]{2})/.test(this.cardExpiration)
                    }
                  }
                  
                  // Our final declaration and initialization of our object using our PaymentInfoValidator prototype
                  const paymentInfoValidator = new PaymentInfoValidator(paymentInfo)
                  paymentInfoValidator.isValidInfo() // true
              </code>
            </pre>
          </div>
          As stated in the code sample above, we use a combination of prototypes with another feature
          of ES6 standard: destructuring assignment, which lets me "take out" the properties of an
          object as if they were variables with the names of the properties themselves. Think of this
          as sending an array of values that you would like your new object to have (and you can do this too
          in JavaScript), but, in a more straightforward way, since you have at least a minimal guide as to
          where your prototype properties should point. Unlike an array, this is a way where you know what
          to pick from an incoming object in your constructor call, instead of memorizing where the correct
          values are located in a given array via positions (what a way to give yourself extra-work).
          </p>
        </li>
      </ul>
      <a id="exceptions" href="/for-the-north-static/pages/posts/prototypes.html#exceptions">
        <h3>
          Exceptions
        </h3>
        </a>
      <p>
        Whoa... That was long, so many samples that we could lose ourselves enjoying
        the possibilities. As James Clear states in his book "Atomic Habits" (not the exact quote):
        "It's not about saying - I have to. It's all about saying - Today, I have
        the chance to change my life for better." We can practice the possibilities a lot
        by ourselves. Now this well said, we jump into exceptions. For now, let's dive into
        the different exceptions we might have:
      </p>
      <ul>
        <li>
          <h4>
            Ignored binding
          </h4>
          <p>
            One way for this to happen is trying to hard bind to an undefined/null context.
            If you try to use <code>call</code> or <code>apply</code> with any of those values,
            the context will fallback to the global object, and from there, the same rules apply.
            If in <code>strict</code> mode, it will be <code>undefined</code>:
            <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-15">
              <label class="collapse-toggle" for="collapse-15" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                  var personName = 'John'

                  function sayHi() {
                    console.log(`Hi, I'm ${this.personName}`)
                  }

                  sayHi.apply(null)  // Hi, I'm John
                  sayHi.call(undefined, sayHi) // Hi, I'm John

                  // using strict mode

                  "use strict"

                  var personName = 'John'

                  function sayHi() {
	                  console.log(`Hi, my name is ${this.personName}`)
                  }

                  sayHi() // Error
              </code>
            </pre>
          </div>
          </p>
        </li>
        <li>
          <h4>
            Indirection
          </h4>
          <p>
            The easiest way to show this is using an IIFE (<a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">Immediately Invoked Function Expression</a>):
            <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-15">
              <label class="collapse-toggle" for="collapse-15" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                var balance = 0
                function bankGreeting() {
                  console.log(`Hi customer, your balance is: $ ${this.balance}`)
                }

                var premiumCustomerAccount = {
                  balance: 100,
                  bankGreeting: bankGreeting,
                }

                var normalCustomerAccount = {
                  balance: 5,
                }; // This semicolon is to prevent execution of a code before the IIFE. Otherwise, you'll get an error.

                (normalCustomerAccount.bankGreeting = premiumCustomerAccount.bankGreeting)() // Hi customer, your balance is: $ 0
              </code>
            </pre>
          </div>
          The assignment of the function results in the function itself, we just have a reference to it,
          allowing you to invoke it immediately as a result of the assignment.
          </p>
          The call site of the is the global scope. This means that the context object will fallback to the global object. Therefore,
          will lead to the variable <code>balance</code> holding the value 0.
        </li>
        <li>
          <h4>Soft Bind</h4>
          <p>
            This is a way of binding that, allows you to fall back to a default object if the one you indicate is not a valid context object or
            you use your functions with different context objects in different situations, but you cling on to one as the default one.
            This is more of an added functionality. I'll take the sample from the book I learned prototypes. (https://github.com/getify/You-Dont-Know-JS).
            Special thanks to https://twitter.com/getify. He's like a wizard in JavaScript.
            It goes like this:
            <div class="code-section">
              <input type="checkbox" class="collapse-checkbox" id="collapse-15">
              <label class="collapse-toggle" for="collapse-15" title="Click to toggle expand/collapse">
              </label>
              <pre class="collapse-content">
              <code class="code language-javascript">
                  if (!Function.prototype.softBind) { // Check if a soft binding already exists
                    Function.prototype.softBind = function(obj) { // Else, we declare a new one
                      var fn = this, // We declare multiple variables from which we'll work with, fn being the function,
                        curried = [].slice.call( arguments, 1 ), // curried being the arguments
                        bound = function bound() { // and bound being the function with the context object applied
                          return fn.apply(
                            (!this ||
                              (typeof window !== "undefined" &&
                                this === window) ||
                              (typeof global !== "undefined" &&
                                this === global) // We ask if we have a 'this' already defined and if 'window' or 'global' (In case you're working in NodeJS)
                            ) ? obj : this, // are the same as 'this' or if this doesn't exist. If this is so, we apply the object as the context.
                            curried.concat.apply( curried, arguments ) // Otherwhise, we apply 'this' as the context object, followed by applying all of
                            // the current arguments to the returned function.
                          );
                        };
                      bound.prototype = Object.create( fn.prototype ); // We set the new prototype from the new function
                      return bound; // Return our new function, soft bound to a default fall back context object.
                    };
                  }
              </code>
            </pre>
          </div>
          </p>
        </li>
      </ul>
    </p>

  </main>
  <script src="/for-the-north-static/public/javascript/prism.js"></script>
</body>
</html>